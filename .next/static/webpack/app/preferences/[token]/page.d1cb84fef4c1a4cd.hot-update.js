/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/preferences/[token]/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fcolinrodrigues%2Ftribe_mvp%2Fsrc%2Fapp%2Fpreferences%2F%5Btoken%5D%2FPreferencesPageClient.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fcolinrodrigues%2Ftribe_mvp%2Fsrc%2Fapp%2Fpreferences%2F%5Btoken%5D%2FPreferencesPageClient.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/preferences/[token]/PreferencesPageClient.tsx */ \"(app-pages-browser)/./src/app/preferences/[token]/PreferencesPageClient.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZjb2xpbnJvZHJpZ3VlcyUyRnRyaWJlX212cCUyRnNyYyUyRmFwcCUyRnByZWZlcmVuY2VzJTJGJTVCdG9rZW4lNUQlMkZQcmVmZXJlbmNlc1BhZ2VDbGllbnQudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHdPQUF1SiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2Y0MmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiL1VzZXJzL2NvbGlucm9kcmlndWVzL3RyaWJlX212cC9zcmMvYXBwL3ByZWZlcmVuY2VzL1t0b2tlbl0vUHJlZmVyZW5jZXNQYWdlQ2xpZW50LnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fcolinrodrigues%2Ftribe_mvp%2Fsrc%2Fapp%2Fpreferences%2F%5Btoken%5D%2FPreferencesPageClient.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/preference-links.ts":
/*!*************************************!*\
  !*** ./src/lib/preference-links.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPreferenceLinkUrl: () => (/* binding */ getPreferenceLinkUrl),\n/* harmony export */   getPreferenceOptions: () => (/* binding */ getPreferenceOptions),\n/* harmony export */   getPreferenceSummary: () => (/* binding */ getPreferenceSummary),\n/* harmony export */   getRecipientByToken: () => (/* binding */ getRecipientByToken),\n/* harmony export */   logPreferenceAccess: () => (/* binding */ logPreferenceAccess),\n/* harmony export */   resetToGroupDefaults: () => (/* binding */ resetToGroupDefaults),\n/* harmony export */   sendPreferenceLink: () => (/* binding */ sendPreferenceLink),\n/* harmony export */   updateRecipientPreferences: () => (/* binding */ updateRecipientPreferences),\n/* harmony export */   validatePreferenceToken: () => (/* binding */ validatePreferenceToken)\n/* harmony export */ });\n/* harmony import */ var _supabase_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase/server */ \"(app-pages-browser)/./src/lib/supabase/server.ts\");\n\n/**\n * Gets recipient information by preference token (no authentication required)\n * This is the entry point for the magic link system\n *\n * @param token - The unique preference token from the magic link\n * @returns Promise resolving to recipient with group info or null if token is invalid\n */ async function getRecipientByToken(token) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    if (!token || token.trim() === '') {\n        return null;\n    }\n    const { data, error } = await supabase.from('recipients').select(\"\\n      *,\\n      recipient_groups(*)\\n    \").eq('preference_token', token).eq('is_active', true).single();\n    if (error) {\n        if (error.code === 'PGRST116') {\n            // No matching token found\n            return null;\n        }\n        console.error('Error fetching recipient by token:', error);\n        return null;\n    }\n    return {\n        ...data,\n        group: Array.isArray(data.recipient_groups) ? data.recipient_groups[0] : data.recipient_groups\n    };\n}\n/**\n * Updates recipient preferences via token (no authentication required)\n * Sets overrides_group_default to true when preferences are changed\n *\n * @param token - The preference token from the magic link\n * @param preferences - The new preference values\n * @returns Promise resolving to boolean indicating success\n */ async function updateRecipientPreferences(token, preferences) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    if (!token || token.trim() === '') {\n        throw new Error('Invalid preference token');\n    }\n    // Validate that the token exists and recipient is active\n    const recipient = await getRecipientByToken(token);\n    if (!recipient) {\n        throw new Error('Invalid or expired preference link');\n    }\n    // Check if the new preferences are different from group defaults\n    const overridesGroupDefault = recipient.group ? preferences.frequency !== recipient.group.default_frequency || !arraysEqual(preferences.preferred_channels, recipient.group.default_channels) : true // If no group, any preferences are considered overrides\n    ;\n    const { error } = await supabase.from('recipients').update({\n        frequency: preferences.frequency,\n        preferred_channels: preferences.preferred_channels,\n        content_types: preferences.content_types,\n        overrides_group_default: overridesGroupDefault\n    }).eq('preference_token', token).eq('is_active', true);\n    if (error) {\n        console.error('Error updating recipient preferences:', error);\n        throw new Error('Failed to update preferences');\n    }\n    return true;\n}\n/**\n * Resets recipient preferences to match their group defaults\n *\n * @param token - The preference token from the magic link\n * @returns Promise resolving to boolean indicating success\n */ async function resetToGroupDefaults(token) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    if (!token || token.trim() === '') {\n        throw new Error('Invalid preference token');\n    }\n    // Get current recipient and group info\n    const recipient = await getRecipientByToken(token);\n    if (!recipient || !recipient.group) {\n        throw new Error('Invalid preference link or no group assigned');\n    }\n    const { error } = await supabase.from('recipients').update({\n        frequency: recipient.group.default_frequency,\n        preferred_channels: recipient.group.default_channels,\n        content_types: [\n            'photos',\n            'text'\n        ],\n        overrides_group_default: false\n    }).eq('preference_token', token).eq('is_active', true);\n    if (error) {\n        console.error('Error resetting to group defaults:', error);\n        throw new Error('Failed to reset preferences');\n    }\n    return true;\n}\n/**\n * Validates that a preference token is valid and active\n *\n * @param token - The preference token to validate\n * @returns Promise resolving to boolean indicating if token is valid\n */ async function validatePreferenceToken(token) {\n    if (!token || token.trim() === '') {\n        return false;\n    }\n    const recipient = await getRecipientByToken(token);\n    return recipient !== null;\n}\n/**\n * Gets the preference link URL for a given token\n *\n * @param token - The preference token\n * @returns Complete preference link URL\n */ function getPreferenceLinkUrl(token) {\n    const baseUrl = \"http://localhost:3000\" || 0;\n    return \"\".concat(baseUrl, \"/preferences/\").concat(token);\n}\n/**\n * Sends a preference link email to a recipient\n * This is a placeholder implementation - actual email sending will be implemented in CRO-24\n *\n * @param email - Recipient's email address\n * @param name - Recipient's name\n * @param token - Preference token for the magic link\n * @param senderName - Name of the parent sending the link (optional)\n * @returns Promise resolving when email is sent\n */ async function sendPreferenceLink(email, name, token, senderName) {\n    const preferenceUrl = getPreferenceLinkUrl(token);\n    // In a real implementation, this would integrate with an email service like SendGrid\n    const emailContent = generatePreferenceLinkEmail(name, preferenceUrl, senderName);\n    console.log(\"Sending preference link email to \".concat(email, \":\"));\n    console.log(\"Subject: \".concat(emailContent.subject));\n    console.log(\"Body: \".concat(emailContent.body));\n    console.log(\"Link: \".concat(preferenceUrl));\n// TODO: Integrate with actual email service in CRO-24\n// Example implementation:\n// await emailService.send({\n//   to: email,\n//   subject: emailContent.subject,\n//   html: emailContent.html,\n//   text: emailContent.text\n// })\n}\n/**\n * Generates email content for preference link emails\n *\n * @param recipientName - Name of the recipient\n * @param preferenceUrl - Complete preference link URL\n * @param senderName - Name of the parent (optional)\n * @returns Email content object with subject and body\n */ function generatePreferenceLinkEmail(recipientName, preferenceUrl, senderName) {\n    const fromText = senderName ? \"from \".concat(senderName) : '';\n    const subject = \"Set your preferences for baby updates \".concat(fromText);\n    const text = \"\\nHi \".concat(recipientName, \",\\n\\nYou've been added to receive baby updates \").concat(fromText, \"!\\n\\nClick the link below to set your preferences for how often you'd like to receive updates and what type of content you'd like to see:\\n\\n\").concat(preferenceUrl, \"\\n\\nThis link is secure and personal to you - no account or password needed.\\n\\nIf you have any questions, please reply to this email.\\n\\nBest regards,\\nThe Tribe Team\\n  \").trim();\n    const html = '\\n<!DOCTYPE html>\\n<html>\\n<head>\\n  <meta charset=\"utf-8\">\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n  <title>Set Your Baby Update Preferences</title>\\n  <style>\\n    body { font-family: -apple-system, BlinkMacSystemFont, \\'Segoe UI\\', system-ui, sans-serif; line-height: 1.6; color: #333; }\\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\\n    .button { display: inline-block; padding: 12px 24px; background: #4F46E5; color: white; text-decoration: none; border-radius: 6px; margin: 20px 0; }\\n    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; font-size: 14px; color: #666; }\\n  </style>\\n</head>\\n<body>\\n  <div class=\"container\">\\n    <h1>Hi '.concat(recipientName, \",</h1>\\n\\n    <p>You've been added to receive baby updates \").concat(fromText, \"!</p>\\n\\n    <p>Click the button below to set your preferences for how often you'd like to receive updates and what type of content you'd like to see:</p>\\n\\n    <a href=\\\"\").concat(preferenceUrl, '\" class=\"button\">Set My Preferences</a>\\n\\n    <p>This link is secure and personal to you - no account or password needed.</p>\\n\\n    <p>If you have any questions, please reply to this email.</p>\\n\\n    <div class=\"footer\">\\n      <p>Best regards,<br>The Tribe Team</p>\\n      <p><small>This email was sent because you were added as a recipient for baby updates. If you believe this was sent in error, please contact the sender.</small></p>\\n    </div>\\n  </div>\\n</body>\\n</html>\\n  ').trim();\n    return {\n        subject,\n        body: text,\n        html,\n        text\n    };\n}\n/**\n * Gets recipient preference summary for display\n * Shows current preferences and indicates if they override group defaults\n *\n * @param token - The preference token\n * @returns Promise resolving to preference summary\n */ async function getPreferenceSummary(token) {\n    const recipient = await getRecipientByToken(token);\n    if (!recipient) {\n        return null;\n    }\n    return {\n        recipient,\n        preferences: {\n            frequency: recipient.frequency,\n            channels: recipient.preferred_channels,\n            contentTypes: recipient.content_types\n        },\n        groupDefaults: recipient.group ? {\n            frequency: recipient.group.default_frequency,\n            channels: recipient.group.default_channels\n        } : undefined,\n        isOverriding: recipient.overrides_group_default\n    };\n}\n/**\n * Gets available preference options for display in forms\n */ function getPreferenceOptions() {\n    return {\n        frequencies: [\n            {\n                value: 'every_update',\n                label: 'Every Update',\n                description: 'Get notified immediately for each new update'\n            },\n            {\n                value: 'daily_digest',\n                label: 'Daily Digest',\n                description: 'Receive a summary once per day'\n            },\n            {\n                value: 'weekly_digest',\n                label: 'Weekly Digest',\n                description: 'Receive a summary once per week'\n            },\n            {\n                value: 'milestones_only',\n                label: 'Milestones Only',\n                description: 'Only receive major milestone updates'\n            }\n        ],\n        channels: [\n            {\n                value: 'email',\n                label: 'Email',\n                description: 'Receive updates via email'\n            },\n            {\n                value: 'sms',\n                label: 'SMS',\n                description: 'Receive updates via text message'\n            },\n            {\n                value: 'whatsapp',\n                label: 'WhatsApp',\n                description: 'Receive updates via WhatsApp'\n            }\n        ],\n        contentTypes: [\n            {\n                value: 'photos',\n                label: 'Photos',\n                description: 'Include photos in updates'\n            },\n            {\n                value: 'text',\n                label: 'Stories & Updates',\n                description: 'Include written stories and descriptions'\n            },\n            {\n                value: 'milestones',\n                label: 'Milestones',\n                description: 'Include milestone achievements and growth tracking'\n            }\n        ]\n    };\n}\n/**\n * Utility function to compare two arrays for equality\n * Used to determine if preferences override group defaults\n *\n * @param arr1 - First array\n * @param arr2 - Second array\n * @returns Boolean indicating if arrays have same elements\n */ function arraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) return false;\n    const sorted1 = [\n        ...arr1\n    ].sort();\n    const sorted2 = [\n        ...arr2\n    ].sort();\n    return sorted1.every((val, i)=>val === sorted2[i]);\n}\n/**\n * Logs preference access for analytics (placeholder)\n * In production, this could track usage patterns\n *\n * @param token - The preference token accessed\n * @param action - The action performed ('view', 'update', 'reset')\n */ async function logPreferenceAccess(token, action) {\n    // In production, this could log to analytics service\n    console.log(\"Preference access logged: \".concat(action, \" for token \").concat(token.slice(0, 8), \"...\"));\n// TODO: Implement actual analytics logging if needed\n// This could track:\n// - How often recipients update their preferences\n// - Which preferences are most commonly changed\n// - Usage patterns for optimization\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcHJlZmVyZW5jZS1saW5rcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWdEO0FBc0JoRDs7Ozs7O0NBTUMsR0FDTSxlQUFlQyxvQkFBb0JDLEtBQWE7SUFDckQsTUFBTUMsV0FBV0gsOERBQVlBO0lBRTdCLElBQUksQ0FBQ0UsU0FBU0EsTUFBTUUsSUFBSSxPQUFPLElBQUk7UUFDakMsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILFNBQzNCSSxJQUFJLENBQUMsY0FDTEMsTUFBTSxDQUFFLCtDQUlSQyxFQUFFLENBQUMsb0JBQW9CUCxPQUN2Qk8sRUFBRSxDQUFDLGFBQWEsTUFDaEJDLE1BQU07SUFFVCxJQUFJSixPQUFPO1FBQ1QsSUFBSUEsTUFBTUssSUFBSSxLQUFLLFlBQVk7WUFDN0IsMEJBQTBCO1lBQzFCLE9BQU87UUFDVDtRQUNBQyxRQUFRTixLQUFLLENBQUMsc0NBQXNDQTtRQUNwRCxPQUFPO0lBQ1Q7SUFFQSxPQUFPO1FBQ0wsR0FBR0QsSUFBSTtRQUNQUSxPQUFPQyxNQUFNQyxPQUFPLENBQUNWLEtBQUtXLGdCQUFnQixJQUFJWCxLQUFLVyxnQkFBZ0IsQ0FBQyxFQUFFLEdBQUdYLEtBQUtXLGdCQUFnQjtJQUNoRztBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVDLDJCQUNwQmYsS0FBYSxFQUNiZ0IsV0FBNkI7SUFFN0IsTUFBTWYsV0FBV0gsOERBQVlBO0lBRTdCLElBQUksQ0FBQ0UsU0FBU0EsTUFBTUUsSUFBSSxPQUFPLElBQUk7UUFDakMsTUFBTSxJQUFJZSxNQUFNO0lBQ2xCO0lBRUEseURBQXlEO0lBQ3pELE1BQU1DLFlBQVksTUFBTW5CLG9CQUFvQkM7SUFDNUMsSUFBSSxDQUFDa0IsV0FBVztRQUNkLE1BQU0sSUFBSUQsTUFBTTtJQUNsQjtJQUVBLGlFQUFpRTtJQUNqRSxNQUFNRSx3QkFBd0JELFVBQVVQ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QkFDUEMsYUFBYTtZQUNmO1NBQ0Q7UUFDRFQsVUFBVTtZQUNSO2dCQUNFTyxPQUFPO2dCQUNQQyxPQUFPO2dCQUNQQyxhQUFhO1lBQ2Y7WUFDQTtnQkFDRUYsT0FBTztnQkFDUEMsT0FBTztnQkFDUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VGLE9BQU87Z0JBQ1BDLE9BQU87Z0JBQ1BDLGFBQWE7WUFDZjtTQUNEO1FBQ0RSLGNBQWM7WUFDWjtnQkFDRU0sT0FBTztnQkFDUEMsT0FBTztnQkFDUEMsYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VGLE9BQU87Z0JBQ1BDLE9BQU87Z0JBQ1BDLGFBQWE7WUFDZjtZQUNBO2dCQUNFRixPQUFPO2dCQUNQQyxPQUFPO2dCQUNQQyxhQUFhO1lBQ2Y7U0FDRDtJQUNIO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3JDLFlBQVlzQyxJQUFjLEVBQUVDLElBQWM7SUFDakQsSUFBSUQsS0FBS0UsTUFBTSxLQUFLRCxLQUFLQyxNQUFNLEVBQUUsT0FBTztJQUV4QyxNQUFNQyxVQUFVO1dBQUlIO0tBQUssQ0FBQ0ksSUFBSTtJQUM5QixNQUFNQyxVQUFVO1dBQUlKO0tBQUssQ0FBQ0csSUFBSTtJQUU5QixPQUFPRCxRQUFRRyxLQUFLLENBQUMsQ0FBQ0MsS0FBS0MsSUFBTUQsUUFBUUYsT0FBTyxDQUFDRyxFQUFFO0FBQ3JEO0FBRUE7Ozs7OztDQU1DLEdBQ00sZUFBZUMsb0JBQ3BCckUsS0FBYSxFQUNic0UsTUFBbUM7SUFFbkMscURBQXFEO0lBQ3JENUQsUUFBUWdDLEdBQUcsQ0FBQyw2QkFBaUQxQyxPQUFwQnNFLFFBQU8sZUFBK0IsT0FBbEJ0RSxNQUFNdUUsS0FBSyxDQUFDLEdBQUcsSUFBRztBQUUvRSxxREFBcUQ7QUFDckQsb0JBQW9CO0FBQ3BCLGtEQUFrRDtBQUNsRCxnREFBZ0Q7QUFDaEQsb0NBQW9DO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcHJlZmVyZW5jZS1saW5rcy50cz9hNTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJy4vc3VwYWJhc2Uvc2VydmVyJ1xuaW1wb3J0IHsgY29va2llcyB9IGZyb20gJ25leHQvaGVhZGVycydcbmltcG9ydCB0eXBlIHsgUmVjaXBpZW50LCBSZWNpcGllbnRHcm91cCB9IGZyb20gJy4vcmVjaXBpZW50cydcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHJlY2lwaWVudCBwcmVmZXJlbmNlIHVwZGF0ZXMgdmlhIG1hZ2ljIGxpbmtcbiAqIE1hdGNoZXMgdGhlIHVwZGF0ZVByZWZlcmVuY2VzU2NoZW1hIHZhbGlkYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXJlbmNlVXBkYXRlIHtcbiAgZnJlcXVlbmN5OiAnZXZlcnlfdXBkYXRlJyB8ICdkYWlseV9kaWdlc3QnIHwgJ3dlZWtseV9kaWdlc3QnIHwgJ21pbGVzdG9uZXNfb25seSdcbiAgcHJlZmVycmVkX2NoYW5uZWxzOiAoJ2VtYWlsJyB8ICdzbXMnIHwgJ3doYXRzYXBwJylbXVxuICBjb250ZW50X3R5cGVzOiAoJ3Bob3RvcycgfCAndGV4dCcgfCAnbWlsZXN0b25lcycpW11cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGVuaGFuY2VkIHJlY2lwaWVudCBkYXRhIHdpdGggZ3JvdXAgaW5mb3JtYXRpb25cbiAqIFVzZWQgaW4gdGhlIHByZWZlcmVuY2UgbWFuYWdlbWVudCBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWNpcGllbnRXaXRoR3JvdXAgZXh0ZW5kcyBSZWNpcGllbnQge1xuICBncm91cDogUmVjaXBpZW50R3JvdXAgfCBudWxsXG59XG5cbi8qKlxuICogR2V0cyByZWNpcGllbnQgaW5mb3JtYXRpb24gYnkgcHJlZmVyZW5jZSB0b2tlbiAobm8gYXV0aGVudGljYXRpb24gcmVxdWlyZWQpXG4gKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIG1hZ2ljIGxpbmsgc3lzdGVtXG4gKlxuICogQHBhcmFtIHRva2VuIC0gVGhlIHVuaXF1ZSBwcmVmZXJlbmNlIHRva2VuIGZyb20gdGhlIG1hZ2ljIGxpbmtcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHJlY2lwaWVudCB3aXRoIGdyb3VwIGluZm8gb3IgbnVsbCBpZiB0b2tlbiBpcyBpbnZhbGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNpcGllbnRCeVRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFJlY2lwaWVudFdpdGhHcm91cCB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoKVxuXG4gIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdyZWNpcGllbnRzJylcbiAgICAuc2VsZWN0KGBcbiAgICAgICosXG4gICAgICByZWNpcGllbnRfZ3JvdXBzKCopXG4gICAgYClcbiAgICAuZXEoJ3ByZWZlcmVuY2VfdG9rZW4nLCB0b2tlbilcbiAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgLnNpbmdsZSgpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHtcbiAgICAgIC8vIE5vIG1hdGNoaW5nIHRva2VuIGZvdW5kXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNpcGllbnQgYnkgdG9rZW46JywgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBncm91cDogQXJyYXkuaXNBcnJheShkYXRhLnJlY2lwaWVudF9ncm91cHMpID8gZGF0YS5yZWNpcGllbnRfZ3JvdXBzWzBdIDogZGF0YS5yZWNpcGllbnRfZ3JvdXBzXG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHJlY2lwaWVudCBwcmVmZXJlbmNlcyB2aWEgdG9rZW4gKG5vIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkKVxuICogU2V0cyBvdmVycmlkZXNfZ3JvdXBfZGVmYXVsdCB0byB0cnVlIHdoZW4gcHJlZmVyZW5jZXMgYXJlIGNoYW5nZWRcbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUaGUgcHJlZmVyZW5jZSB0b2tlbiBmcm9tIHRoZSBtYWdpYyBsaW5rXG4gKiBAcGFyYW0gcHJlZmVyZW5jZXMgLSBUaGUgbmV3IHByZWZlcmVuY2UgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBib29sZWFuIGluZGljYXRpbmcgc3VjY2Vzc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUmVjaXBpZW50UHJlZmVyZW5jZXMoXG4gIHRva2VuOiBzdHJpbmcsXG4gIHByZWZlcmVuY2VzOiBQcmVmZXJlbmNlVXBkYXRlXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoKVxuXG4gIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmZXJlbmNlIHRva2VuJylcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHRva2VuIGV4aXN0cyBhbmQgcmVjaXBpZW50IGlzIGFjdGl2ZVxuICBjb25zdCByZWNpcGllbnQgPSBhd2FpdCBnZXRSZWNpcGllbnRCeVRva2VuKHRva2VuKVxuICBpZiAoIXJlY2lwaWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciBleHBpcmVkIHByZWZlcmVuY2UgbGluaycpXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgbmV3IHByZWZlcmVuY2VzIGFyZSBkaWZmZXJlbnQgZnJvbSBncm91cCBkZWZhdWx0c1xuICBjb25zdCBvdmVycmlkZXNHcm91cERlZmF1bHQgPSByZWNpcGllbnQuZ3JvdXAgP1xuICAgIHByZWZlcmVuY2VzLmZyZXF1ZW5jeSAhPT0gcmVjaXBpZW50Lmdyb3VwLmRlZmF1bHRfZnJlcXVlbmN5IHx8XG4gICAgIWFycmF5c0VxdWFsKHByZWZlcmVuY2VzLnByZWZlcnJlZF9jaGFubmVscywgcmVjaXBpZW50Lmdyb3VwLmRlZmF1bHRfY2hhbm5lbHMpIDpcbiAgICB0cnVlIC8vIElmIG5vIGdyb3VwLCBhbnkgcHJlZmVyZW5jZXMgYXJlIGNvbnNpZGVyZWQgb3ZlcnJpZGVzXG5cbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncmVjaXBpZW50cycpXG4gICAgLnVwZGF0ZSh7XG4gICAgICBmcmVxdWVuY3k6IHByZWZlcmVuY2VzLmZyZXF1ZW5jeSxcbiAgICAgIHByZWZlcnJlZF9jaGFubmVsczogcHJlZmVyZW5jZXMucHJlZmVycmVkX2NoYW5uZWxzLFxuICAgICAgY29udGVudF90eXBlczogcHJlZmVyZW5jZXMuY29udGVudF90eXBlcyxcbiAgICAgIG92ZXJyaWRlc19ncm91cF9kZWZhdWx0OiBvdmVycmlkZXNHcm91cERlZmF1bHRcbiAgICB9KVxuICAgIC5lcSgncHJlZmVyZW5jZV90b2tlbicsIHRva2VuKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByZWNpcGllbnQgcHJlZmVyZW5jZXM6JywgZXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHByZWZlcmVuY2VzJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogUmVzZXRzIHJlY2lwaWVudCBwcmVmZXJlbmNlcyB0byBtYXRjaCB0aGVpciBncm91cCBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSBwcmVmZXJlbmNlIHRva2VuIGZyb20gdGhlIG1hZ2ljIGxpbmtcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGJvb2xlYW4gaW5kaWNhdGluZyBzdWNjZXNzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNldFRvR3JvdXBEZWZhdWx0cyh0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KClcblxuICBpZiAoIXRva2VuIHx8IHRva2VuLnRyaW0oKSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJlZmVyZW5jZSB0b2tlbicpXG4gIH1cblxuICAvLyBHZXQgY3VycmVudCByZWNpcGllbnQgYW5kIGdyb3VwIGluZm9cbiAgY29uc3QgcmVjaXBpZW50ID0gYXdhaXQgZ2V0UmVjaXBpZW50QnlUb2tlbih0b2tlbilcbiAgaWYgKCFyZWNpcGllbnQgfHwgIXJlY2lwaWVudC5ncm91cCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmZXJlbmNlIGxpbmsgb3Igbm8gZ3JvdXAgYXNzaWduZWQnKVxuICB9XG5cbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgncmVjaXBpZW50cycpXG4gICAgLnVwZGF0ZSh7XG4gICAgICBmcmVxdWVuY3k6IHJlY2lwaWVudC5ncm91cC5kZWZhdWx0X2ZyZXF1ZW5jeSxcbiAgICAgIHByZWZlcnJlZF9jaGFubmVsczogcmVjaXBpZW50Lmdyb3VwLmRlZmF1bHRfY2hhbm5lbHMsXG4gICAgICBjb250ZW50X3R5cGVzOiBbJ3Bob3RvcycsICd0ZXh0J10sIC8vIERlZmF1bHQgY29udGVudCB0eXBlc1xuICAgICAgb3ZlcnJpZGVzX2dyb3VwX2RlZmF1bHQ6IGZhbHNlXG4gICAgfSlcbiAgICAuZXEoJ3ByZWZlcmVuY2VfdG9rZW4nLCB0b2tlbilcbiAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIHRvIGdyb3VwIGRlZmF1bHRzOicsIGVycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc2V0IHByZWZlcmVuY2VzJylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSBwcmVmZXJlbmNlIHRva2VuIGlzIHZhbGlkIGFuZCBhY3RpdmVcbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUaGUgcHJlZmVyZW5jZSB0b2tlbiB0byB2YWxpZGF0ZVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRva2VuIGlzIHZhbGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVByZWZlcmVuY2VUb2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcmVjaXBpZW50ID0gYXdhaXQgZ2V0UmVjaXBpZW50QnlUb2tlbih0b2tlbilcbiAgcmV0dXJuIHJlY2lwaWVudCAhPT0gbnVsbFxufVxuXG4vKipcbiAqIEdldHMgdGhlIHByZWZlcmVuY2UgbGluayBVUkwgZm9yIGEgZ2l2ZW4gdG9rZW5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUaGUgcHJlZmVyZW5jZSB0b2tlblxuICogQHJldHVybnMgQ29tcGxldGUgcHJlZmVyZW5jZSBsaW5rIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZUxpbmtVcmwodG9rZW46IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TSVRFX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJ1xuICByZXR1cm4gYCR7YmFzZVVybH0vcHJlZmVyZW5jZXMvJHt0b2tlbn1gXG59XG5cbi8qKlxuICogU2VuZHMgYSBwcmVmZXJlbmNlIGxpbmsgZW1haWwgdG8gYSByZWNpcGllbnRcbiAqIFRoaXMgaXMgYSBwbGFjZWhvbGRlciBpbXBsZW1lbnRhdGlvbiAtIGFjdHVhbCBlbWFpbCBzZW5kaW5nIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gQ1JPLTI0XG4gKlxuICogQHBhcmFtIGVtYWlsIC0gUmVjaXBpZW50J3MgZW1haWwgYWRkcmVzc1xuICogQHBhcmFtIG5hbWUgLSBSZWNpcGllbnQncyBuYW1lXG4gKiBAcGFyYW0gdG9rZW4gLSBQcmVmZXJlbmNlIHRva2VuIGZvciB0aGUgbWFnaWMgbGlua1xuICogQHBhcmFtIHNlbmRlck5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgc2VuZGluZyB0aGUgbGluayAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIGVtYWlsIGlzIHNlbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRQcmVmZXJlbmNlTGluayhcbiAgZW1haWw6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICB0b2tlbjogc3RyaW5nLFxuICBzZW5kZXJOYW1lPzogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcHJlZmVyZW5jZVVybCA9IGdldFByZWZlcmVuY2VMaW5rVXJsKHRva2VuKVxuXG4gIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCBhbiBlbWFpbCBzZXJ2aWNlIGxpa2UgU2VuZEdyaWRcbiAgY29uc3QgZW1haWxDb250ZW50ID0gZ2VuZXJhdGVQcmVmZXJlbmNlTGlua0VtYWlsKG5hbWUsIHByZWZlcmVuY2VVcmwsIHNlbmRlck5hbWUpXG5cbiAgY29uc29sZS5sb2coYFNlbmRpbmcgcHJlZmVyZW5jZSBsaW5rIGVtYWlsIHRvICR7ZW1haWx9OmApXG4gIGNvbnNvbGUubG9nKGBTdWJqZWN0OiAke2VtYWlsQ29udGVudC5zdWJqZWN0fWApXG4gIGNvbnNvbGUubG9nKGBCb2R5OiAke2VtYWlsQ29udGVudC5ib2R5fWApXG4gIGNvbnNvbGUubG9nKGBMaW5rOiAke3ByZWZlcmVuY2VVcmx9YClcblxuICAvLyBUT0RPOiBJbnRlZ3JhdGUgd2l0aCBhY3R1YWwgZW1haWwgc2VydmljZSBpbiBDUk8tMjRcbiAgLy8gRXhhbXBsZSBpbXBsZW1lbnRhdGlvbjpcbiAgLy8gYXdhaXQgZW1haWxTZXJ2aWNlLnNlbmQoe1xuICAvLyAgIHRvOiBlbWFpbCxcbiAgLy8gICBzdWJqZWN0OiBlbWFpbENvbnRlbnQuc3ViamVjdCxcbiAgLy8gICBodG1sOiBlbWFpbENvbnRlbnQuaHRtbCxcbiAgLy8gICB0ZXh0OiBlbWFpbENvbnRlbnQudGV4dFxuICAvLyB9KVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBlbWFpbCBjb250ZW50IGZvciBwcmVmZXJlbmNlIGxpbmsgZW1haWxzXG4gKlxuICogQHBhcmFtIHJlY2lwaWVudE5hbWUgLSBOYW1lIG9mIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBwcmVmZXJlbmNlVXJsIC0gQ29tcGxldGUgcHJlZmVyZW5jZSBsaW5rIFVSTFxuICogQHBhcmFtIHNlbmRlck5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgRW1haWwgY29udGVudCBvYmplY3Qgd2l0aCBzdWJqZWN0IGFuZCBib2R5XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlZmVyZW5jZUxpbmtFbWFpbChcbiAgcmVjaXBpZW50TmFtZTogc3RyaW5nLFxuICBwcmVmZXJlbmNlVXJsOiBzdHJpbmcsXG4gIHNlbmRlck5hbWU/OiBzdHJpbmdcbik6IHtcbiAgc3ViamVjdDogc3RyaW5nXG4gIGJvZHk6IHN0cmluZ1xuICBodG1sOiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG59IHtcbiAgY29uc3QgZnJvbVRleHQgPSBzZW5kZXJOYW1lID8gYGZyb20gJHtzZW5kZXJOYW1lfWAgOiAnJ1xuXG4gIGNvbnN0IHN1YmplY3QgPSBgU2V0IHlvdXIgcHJlZmVyZW5jZXMgZm9yIGJhYnkgdXBkYXRlcyAke2Zyb21UZXh0fWBcblxuICBjb25zdCB0ZXh0ID0gYFxuSGkgJHtyZWNpcGllbnROYW1lfSxcblxuWW91J3ZlIGJlZW4gYWRkZWQgdG8gcmVjZWl2ZSBiYWJ5IHVwZGF0ZXMgJHtmcm9tVGV4dH0hXG5cbkNsaWNrIHRoZSBsaW5rIGJlbG93IHRvIHNldCB5b3VyIHByZWZlcmVuY2VzIGZvciBob3cgb2Z0ZW4geW91J2QgbGlrZSB0byByZWNlaXZlIHVwZGF0ZXMgYW5kIHdoYXQgdHlwZSBvZiBjb250ZW50IHlvdSdkIGxpa2UgdG8gc2VlOlxuXG4ke3ByZWZlcmVuY2VVcmx9XG5cblRoaXMgbGluayBpcyBzZWN1cmUgYW5kIHBlcnNvbmFsIHRvIHlvdSAtIG5vIGFjY291bnQgb3IgcGFzc3dvcmQgbmVlZGVkLlxuXG5JZiB5b3UgaGF2ZSBhbnkgcXVlc3Rpb25zLCBwbGVhc2UgcmVwbHkgdG8gdGhpcyBlbWFpbC5cblxuQmVzdCByZWdhcmRzLFxuVGhlIFRyaWJlIFRlYW1cbiAgYC50cmltKClcblxuICBjb25zdCBodG1sID0gYFxuPCFET0NUWVBFIGh0bWw+XG48aHRtbD5cbjxoZWFkPlxuICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcIj5cbiAgPHRpdGxlPlNldCBZb3VyIEJhYnkgVXBkYXRlIFByZWZlcmVuY2VzPC90aXRsZT5cbiAgPHN0eWxlPlxuICAgIGJvZHkgeyBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWY7IGxpbmUtaGVpZ2h0OiAxLjY7IGNvbG9yOiAjMzMzOyB9XG4gICAgLmNvbnRhaW5lciB7IG1heC13aWR0aDogNjAwcHg7IG1hcmdpbjogMCBhdXRvOyBwYWRkaW5nOiAyMHB4OyB9XG4gICAgLmJ1dHRvbiB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgcGFkZGluZzogMTJweCAyNHB4OyBiYWNrZ3JvdW5kOiAjNEY0NkU1OyBjb2xvcjogd2hpdGU7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgYm9yZGVyLXJhZGl1czogNnB4OyBtYXJnaW46IDIwcHggMDsgfVxuICAgIC5mb290ZXIgeyBtYXJnaW4tdG9wOiA0MHB4OyBwYWRkaW5nLXRvcDogMjBweDsgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7IGZvbnQtc2l6ZTogMTRweDsgY29sb3I6ICM2NjY7IH1cbiAgPC9zdHlsZT5cbjwvaGVhZD5cbjxib2R5PlxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgPGgxPkhpICR7cmVjaXBpZW50TmFtZX0sPC9oMT5cblxuICAgIDxwPllvdSd2ZSBiZWVuIGFkZGVkIHRvIHJlY2VpdmUgYmFieSB1cGRhdGVzICR7ZnJvbVRleHR9ITwvcD5cblxuICAgIDxwPkNsaWNrIHRoZSBidXR0b24gYmVsb3cgdG8gc2V0IHlvdXIgcHJlZmVyZW5jZXMgZm9yIGhvdyBvZnRlbiB5b3UnZCBsaWtlIHRvIHJlY2VpdmUgdXBkYXRlcyBhbmQgd2hhdCB0eXBlIG9mIGNvbnRlbnQgeW91J2QgbGlrZSB0byBzZWU6PC9wPlxuXG4gICAgPGEgaHJlZj1cIiR7cHJlZmVyZW5jZVVybH1cIiBjbGFzcz1cImJ1dHRvblwiPlNldCBNeSBQcmVmZXJlbmNlczwvYT5cblxuICAgIDxwPlRoaXMgbGluayBpcyBzZWN1cmUgYW5kIHBlcnNvbmFsIHRvIHlvdSAtIG5vIGFjY291bnQgb3IgcGFzc3dvcmQgbmVlZGVkLjwvcD5cblxuICAgIDxwPklmIHlvdSBoYXZlIGFueSBxdWVzdGlvbnMsIHBsZWFzZSByZXBseSB0byB0aGlzIGVtYWlsLjwvcD5cblxuICAgIDxkaXYgY2xhc3M9XCJmb290ZXJcIj5cbiAgICAgIDxwPkJlc3QgcmVnYXJkcyw8YnI+VGhlIFRyaWJlIFRlYW08L3A+XG4gICAgICA8cD48c21hbGw+VGhpcyBlbWFpbCB3YXMgc2VudCBiZWNhdXNlIHlvdSB3ZXJlIGFkZGVkIGFzIGEgcmVjaXBpZW50IGZvciBiYWJ5IHVwZGF0ZXMuIElmIHlvdSBiZWxpZXZlIHRoaXMgd2FzIHNlbnQgaW4gZXJyb3IsIHBsZWFzZSBjb250YWN0IHRoZSBzZW5kZXIuPC9zbWFsbD48L3A+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9ib2R5PlxuPC9odG1sPlxuICBgLnRyaW0oKVxuXG4gIHJldHVybiB7XG4gICAgc3ViamVjdCxcbiAgICBib2R5OiB0ZXh0LFxuICAgIGh0bWwsXG4gICAgdGV4dFxuICB9XG59XG5cbi8qKlxuICogR2V0cyByZWNpcGllbnQgcHJlZmVyZW5jZSBzdW1tYXJ5IGZvciBkaXNwbGF5XG4gKiBTaG93cyBjdXJyZW50IHByZWZlcmVuY2VzIGFuZCBpbmRpY2F0ZXMgaWYgdGhleSBvdmVycmlkZSBncm91cCBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSBwcmVmZXJlbmNlIHRva2VuXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBwcmVmZXJlbmNlIHN1bW1hcnlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByZWZlcmVuY2VTdW1tYXJ5KHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHtcbiAgcmVjaXBpZW50OiBSZWNpcGllbnRXaXRoR3JvdXBcbiAgcHJlZmVyZW5jZXM6IHtcbiAgICBmcmVxdWVuY3k6IHN0cmluZ1xuICAgIGNoYW5uZWxzOiBzdHJpbmdbXVxuICAgIGNvbnRlbnRUeXBlczogc3RyaW5nW11cbiAgfVxuICBncm91cERlZmF1bHRzPzoge1xuICAgIGZyZXF1ZW5jeTogc3RyaW5nXG4gICAgY2hhbm5lbHM6IHN0cmluZ1tdXG4gIH1cbiAgaXNPdmVycmlkaW5nOiBib29sZWFuXG59IHwgbnVsbD4ge1xuICBjb25zdCByZWNpcGllbnQgPSBhd2FpdCBnZXRSZWNpcGllbnRCeVRva2VuKHRva2VuKVxuXG4gIGlmICghcmVjaXBpZW50KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVjaXBpZW50LFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICBmcmVxdWVuY3k6IHJlY2lwaWVudC5mcmVxdWVuY3ksXG4gICAgICBjaGFubmVsczogcmVjaXBpZW50LnByZWZlcnJlZF9jaGFubmVscyxcbiAgICAgIGNvbnRlbnRUeXBlczogcmVjaXBpZW50LmNvbnRlbnRfdHlwZXNcbiAgICB9LFxuICAgIGdyb3VwRGVmYXVsdHM6IHJlY2lwaWVudC5ncm91cCA/IHtcbiAgICAgIGZyZXF1ZW5jeTogcmVjaXBpZW50Lmdyb3VwLmRlZmF1bHRfZnJlcXVlbmN5LFxuICAgICAgY2hhbm5lbHM6IHJlY2lwaWVudC5ncm91cC5kZWZhdWx0X2NoYW5uZWxzXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICBpc092ZXJyaWRpbmc6IHJlY2lwaWVudC5vdmVycmlkZXNfZ3JvdXBfZGVmYXVsdFxuICB9XG59XG5cbi8qKlxuICogR2V0cyBhdmFpbGFibGUgcHJlZmVyZW5jZSBvcHRpb25zIGZvciBkaXNwbGF5IGluIGZvcm1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlT3B0aW9ucygpIHtcbiAgcmV0dXJuIHtcbiAgICBmcmVxdWVuY2llczogW1xuICAgICAge1xuICAgICAgICB2YWx1ZTogJ2V2ZXJ5X3VwZGF0ZScsXG4gICAgICAgIGxhYmVsOiAnRXZlcnkgVXBkYXRlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdHZXQgbm90aWZpZWQgaW1tZWRpYXRlbHkgZm9yIGVhY2ggbmV3IHVwZGF0ZSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiAnZGFpbHlfZGlnZXN0JyxcbiAgICAgICAgbGFiZWw6ICdEYWlseSBEaWdlc3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1JlY2VpdmUgYSBzdW1tYXJ5IG9uY2UgcGVyIGRheSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiAnd2Vla2x5X2RpZ2VzdCcsXG4gICAgICAgIGxhYmVsOiAnV2Vla2x5IERpZ2VzdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmVjZWl2ZSBhIHN1bW1hcnkgb25jZSBwZXIgd2VlaydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiAnbWlsZXN0b25lc19vbmx5JyxcbiAgICAgICAgbGFiZWw6ICdNaWxlc3RvbmVzIE9ubHknLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09ubHkgcmVjZWl2ZSBtYWpvciBtaWxlc3RvbmUgdXBkYXRlcydcbiAgICAgIH1cbiAgICBdLFxuICAgIGNoYW5uZWxzOiBbXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiAnZW1haWwnLFxuICAgICAgICBsYWJlbDogJ0VtYWlsJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZWNlaXZlIHVwZGF0ZXMgdmlhIGVtYWlsJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6ICdzbXMnLFxuICAgICAgICBsYWJlbDogJ1NNUycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmVjZWl2ZSB1cGRhdGVzIHZpYSB0ZXh0IG1lc3NhZ2UnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2YWx1ZTogJ3doYXRzYXBwJyxcbiAgICAgICAgbGFiZWw6ICdXaGF0c0FwcCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmVjZWl2ZSB1cGRhdGVzIHZpYSBXaGF0c0FwcCdcbiAgICAgIH1cbiAgICBdLFxuICAgIGNvbnRlbnRUeXBlczogW1xuICAgICAge1xuICAgICAgICB2YWx1ZTogJ3Bob3RvcycsXG4gICAgICAgIGxhYmVsOiAnUGhvdG9zJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdJbmNsdWRlIHBob3RvcyBpbiB1cGRhdGVzJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6ICd0ZXh0JyxcbiAgICAgICAgbGFiZWw6ICdTdG9yaWVzICYgVXBkYXRlcycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSB3cml0dGVuIHN0b3JpZXMgYW5kIGRlc2NyaXB0aW9ucydcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiAnbWlsZXN0b25lcycsXG4gICAgICAgIGxhYmVsOiAnTWlsZXN0b25lcycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSBtaWxlc3RvbmUgYWNoaWV2ZW1lbnRzIGFuZCBncm93dGggdHJhY2tpbmcnXG4gICAgICB9XG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb21wYXJlIHR3byBhcnJheXMgZm9yIGVxdWFsaXR5XG4gKiBVc2VkIHRvIGRldGVybWluZSBpZiBwcmVmZXJlbmNlcyBvdmVycmlkZSBncm91cCBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSBhcnIxIC0gRmlyc3QgYXJyYXlcbiAqIEBwYXJhbSBhcnIyIC0gU2Vjb25kIGFycmF5XG4gKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgaWYgYXJyYXlzIGhhdmUgc2FtZSBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhcnIxOiBzdHJpbmdbXSwgYXJyMjogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3Qgc29ydGVkMSA9IFsuLi5hcnIxXS5zb3J0KClcbiAgY29uc3Qgc29ydGVkMiA9IFsuLi5hcnIyXS5zb3J0KClcblxuICByZXR1cm4gc29ydGVkMS5ldmVyeSgodmFsLCBpKSA9PiB2YWwgPT09IHNvcnRlZDJbaV0pXG59XG5cbi8qKlxuICogTG9ncyBwcmVmZXJlbmNlIGFjY2VzcyBmb3IgYW5hbHl0aWNzIChwbGFjZWhvbGRlcilcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgY291bGQgdHJhY2sgdXNhZ2UgcGF0dGVybnNcbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUaGUgcHJlZmVyZW5jZSB0b2tlbiBhY2Nlc3NlZFxuICogQHBhcmFtIGFjdGlvbiAtIFRoZSBhY3Rpb24gcGVyZm9ybWVkICgndmlldycsICd1cGRhdGUnLCAncmVzZXQnKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9nUHJlZmVyZW5jZUFjY2VzcyhcbiAgdG9rZW46IHN0cmluZyxcbiAgYWN0aW9uOiAndmlldycgfCAndXBkYXRlJyB8ICdyZXNldCdcbik6IFByb21pc2U8dm9pZD4ge1xuICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIGNvdWxkIGxvZyB0byBhbmFseXRpY3Mgc2VydmljZVxuICBjb25zb2xlLmxvZyhgUHJlZmVyZW5jZSBhY2Nlc3MgbG9nZ2VkOiAke2FjdGlvbn0gZm9yIHRva2VuICR7dG9rZW4uc2xpY2UoMCwgOCl9Li4uYClcblxuICAvLyBUT0RPOiBJbXBsZW1lbnQgYWN0dWFsIGFuYWx5dGljcyBsb2dnaW5nIGlmIG5lZWRlZFxuICAvLyBUaGlzIGNvdWxkIHRyYWNrOlxuICAvLyAtIEhvdyBvZnRlbiByZWNpcGllbnRzIHVwZGF0ZSB0aGVpciBwcmVmZXJlbmNlc1xuICAvLyAtIFdoaWNoIHByZWZlcmVuY2VzIGFyZSBtb3N0IGNvbW1vbmx5IGNoYW5nZWRcbiAgLy8gLSBVc2FnZSBwYXR0ZXJucyBmb3Igb3B0aW1pemF0aW9uXG59Il0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImdldFJlY2lwaWVudEJ5VG9rZW4iLCJ0b2tlbiIsInN1cGFiYXNlIiwidHJpbSIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImNvZGUiLCJjb25zb2xlIiwiZ3JvdXAiLCJBcnJheSIsImlzQXJyYXkiLCJyZWNpcGllbnRfZ3JvdXBzIiwidXBkYXRlUmVjaXBpZW50UHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsIkVycm9yIiwicmVjaXBpZW50Iiwib3ZlcnJpZGVzR3JvdXBEZWZhdWx0IiwiZnJlcXVlbmN5IiwiZGVmYXVsdF9mcmVxdWVuY3kiLCJhcnJheXNFcXVhbCIsInByZWZlcnJlZF9jaGFubmVscyIsImRlZmF1bHRfY2hhbm5lbHMiLCJ1cGRhdGUiLCJjb250ZW50X3R5cGVzIiwib3ZlcnJpZGVzX2dyb3VwX2RlZmF1bHQiLCJyZXNldFRvR3JvdXBEZWZhdWx0cyIsInZhbGlkYXRlUHJlZmVyZW5jZVRva2VuIiwiZ2V0UHJlZmVyZW5jZUxpbmtVcmwiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NJVEVfVVJMIiwic2VuZFByZWZlcmVuY2VMaW5rIiwiZW1haWwiLCJuYW1lIiwic2VuZGVyTmFtZSIsInByZWZlcmVuY2VVcmwiLCJlbWFpbENvbnRlbnQiLCJnZW5lcmF0ZVByZWZlcmVuY2VMaW5rRW1haWwiLCJsb2ciLCJzdWJqZWN0IiwiYm9keSIsInJlY2lwaWVudE5hbWUiLCJmcm9tVGV4dCIsInRleHQiLCJodG1sIiwiZ2V0UHJlZmVyZW5jZVN1bW1hcnkiLCJjaGFubmVscyIsImNvbnRlbnRUeXBlcyIsImdyb3VwRGVmYXVsdHMiLCJ1bmRlZmluZWQiLCJpc092ZXJyaWRpbmciLCJnZXRQcmVmZXJlbmNlT3B0aW9ucyIsImZyZXF1ZW5jaWVzIiwidmFsdWUiLCJsYWJlbCIsImRlc2NyaXB0aW9uIiwiYXJyMSIsImFycjIiLCJsZW5ndGgiLCJzb3J0ZWQxIiwic29ydCIsInNvcnRlZDIiLCJldmVyeSIsInZhbCIsImkiLCJsb2dQcmVmZXJlbmNlQWNjZXNzIiwiYWN0aW9uIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/preference-links.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/supabase/server.ts":
/*!************************************!*\
  !*** ./src/lib/supabase/server.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_ssr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/ssr */ \"(app-pages-browser)/./node_modules/@supabase/ssr/dist/index.mjs\");\n\nfunction createClient(cookieStore) {\n    return (0,_supabase_ssr__WEBPACK_IMPORTED_MODULE_0__.createServerClient)(\"https://advbcfkisejskhskrmqw.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFkdmJjZmtpc2Vqc2toc2tybXF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMjYxNTQsImV4cCI6MjA3MzYwMjE1NH0.PscxgrYSa54u37Nwi08QyTmKs6TEdMEcPYdHUTxLi18\", {\n        cookies: {\n            get (name) {\n                var _cookieStore_get;\n                return (_cookieStore_get = cookieStore.get(name)) === null || _cookieStore_get === void 0 ? void 0 : _cookieStore_get.value;\n            },\n            set (name, value, options) {\n                try {\n                    cookieStore.set(name, value, options);\n                } catch (e) {\n                // The `set` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            },\n            remove (name, options) {\n                try {\n                    cookieStore.set(name, '', {\n                        ...options,\n                        maxAge: 0\n                    });\n                } catch (e) {\n                // The `delete` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            }\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2Uvc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNFO0FBRy9ELFNBQVNDLGFBQWFDLFdBRzVCO0lBQ0MsT0FBT0YsaUVBQWtCQSxDQUN2QkcsMENBQW9DLEVBQ3BDQSxrTkFBeUMsRUFDekM7UUFDRUksU0FBUztZQUNQQyxLQUFJQyxJQUFZO29CQUNQUDtnQkFBUCxRQUFPQSxtQkFBQUEsWUFBWU0sR0FBRyxDQUFDQyxtQkFBaEJQLHVDQUFBQSxpQkFBdUJRLEtBQUs7WUFDckM7WUFDQUMsS0FBSUYsSUFBWSxFQUFFQyxLQUFhLEVBQUVFLE9BQXNCO2dCQUNyRCxJQUFJO29CQUNGVixZQUFZUyxHQUFHLENBQUNGLE1BQU1DLE9BQU9FO2dCQUMvQixFQUFFLFVBQU07Z0JBQ04sdURBQXVEO2dCQUN2RCx3REFBd0Q7Z0JBQ3hELGlCQUFpQjtnQkFDbkI7WUFDRjtZQUNBQyxRQUFPSixJQUFZLEVBQUVHLE9BQXNCO2dCQUN6QyxJQUFJO29CQUNGVixZQUFZUyxHQUFHLENBQUNGLE1BQU0sSUFBSTt3QkFBRSxHQUFHRyxPQUFPO3dCQUFFRSxRQUFRO29CQUFFO2dCQUNwRCxFQUFFLFVBQU07Z0JBQ04sMERBQTBEO2dCQUMxRCx3REFBd0Q7Z0JBQ3hELGlCQUFpQjtnQkFDbkI7WUFDRjtRQUNGO0lBQ0Y7QUFFSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3N1cGFiYXNlL3NlcnZlci50cz8yZThlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlcnZlckNsaWVudCwgdHlwZSBDb29raWVPcHRpb25zIH0gZnJvbSAnQHN1cGFiYXNlL3NzcidcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UgfSBmcm9tICcuLi90eXBlcy9kYXRhYmFzZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChjb29raWVTdG9yZToge1xuICBnZXQ6IChuYW1lOiBzdHJpbmcpID0+IHsgdmFsdWU6IHN0cmluZyB9IHwgdW5kZWZpbmVkXG4gIHNldDogKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9ucz86IGFueSkgPT4gdm9pZFxufSkge1xuICByZXR1cm4gY3JlYXRlU2VydmVyQ2xpZW50PERhdGFiYXNlPihcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhLFxuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZISxcbiAgICB7XG4gICAgICBjb29raWVzOiB7XG4gICAgICAgIGdldChuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY29va2llU3RvcmUuZ2V0KG5hbWUpPy52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBzZXQobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBvcHRpb25zOiBDb29raWVPcHRpb25zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvb2tpZVN0b3JlLnNldChuYW1lLCB2YWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIFRoZSBgc2V0YCBtZXRob2Qgd2FzIGNhbGxlZCBmcm9tIGEgU2VydmVyIENvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGlnbm9yZWQgaWYgeW91IGhhdmUgbWlkZGxld2FyZSByZWZyZXNoaW5nXG4gICAgICAgICAgICAvLyB1c2VyIHNlc3Npb25zLlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlKG5hbWU6IHN0cmluZywgb3B0aW9uczogQ29va2llT3B0aW9ucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWVTdG9yZS5zZXQobmFtZSwgJycsIHsgLi4ub3B0aW9ucywgbWF4QWdlOiAwIH0pXG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBUaGUgYGRlbGV0ZWAgbWV0aG9kIHdhcyBjYWxsZWQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBpZ25vcmVkIGlmIHlvdSBoYXZlIG1pZGRsZXdhcmUgcmVmcmVzaGluZ1xuICAgICAgICAgICAgLy8gdXNlciBzZXNzaW9ucy5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgKVxufSJdLCJuYW1lcyI6WyJjcmVhdGVTZXJ2ZXJDbGllbnQiLCJjcmVhdGVDbGllbnQiLCJjb29raWVTdG9yZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImNvb2tpZXMiLCJnZXQiLCJuYW1lIiwidmFsdWUiLCJzZXQiLCJvcHRpb25zIiwicmVtb3ZlIiwibWF4QWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase/server.ts\n"));

/***/ })

});